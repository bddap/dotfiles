#!/usr/bin/env python3
"""
Arrange tmux panes in a dwindling binary partition layout.

Original logic by Suraj N. Kurapati (https://github.com/sunaku/home).

This script doesn't work. Some day soon I will fix it up.
"""

import subprocess
import sys
from dataclasses import dataclass
from typing import Iterable, List, Sequence

_ALLOWED_FLAGS = frozenset("tblrhvsc")


def select(haystack: str, default: str, override: str) -> bool:
    assert (default not in haystack) or (override not in haystack)
    return override in haystack


@dataclass(frozen=True)
class Config:
    up: bool
    right: bool
    spiral: bool

    @staticmethod
    def from_flags(flags: str) -> "Config":
        unknown_flags = sorted(set(flags) - _ALLOWED_FLAGS)
        if unknown_flags:
            raise ValueError(f"Invalid flag(s): {', '.join(unknown_flags)}")
        return Config(
            up=select(flags, "b", "t"),
            right=select(flags, "l", "r"),
            spiral=select(flags, "c", "s"),
        )


@dataclass(frozen=True)
class Orientation:
    corner_tb: bool
    spiral_tb: bool
    corner_lr: bool
    spiral_lr: bool
    modulo_hv: int
    is_vertical: bool
    is_spiral: bool

    @classmethod
    def from_flags(cls, flags: Sequence[str]) -> "Orientation":
        flag_string = "".join(flags).lower()
        unknown_flags = sorted(set(flag_string) - _ALLOWED_FLAGS)
        if unknown_flags:
            raise ValueError(f"Invalid flag(s): {', '.join(unknown_flags)}")

        top = "t" in flag_string
        bottom = "b" in flag_string
        if top and bottom:
            raise ValueError("Flags 't' and 'b' are mutually exclusive.")

        left = "l" in flag_string
        right = "r" in flag_string
        if left and right:
            raise ValueError("Flags 'l' and 'r' are mutually exclusive.")

        horizontal = "h" in flag_string
        vertical = "v" in flag_string
        if horizontal and vertical:
            raise ValueError("Flags 'h' and 'v' are mutually exclusive.")

        corner = "c" in flag_string
        spiral = "s" in flag_string
        if corner and spiral:
            raise ValueError("Flags 'c' and 's' are mutually exclusive.")

        corner_tb = top
        spiral_tb = not top
        corner_lr = left
        spiral_lr = not left
        modulo_hv = 0 if horizontal else 1
        is_vertical = not horizontal
        is_spiral = spiral

        return cls(
            corner_tb=corner_tb,
            spiral_tb=spiral_tb,
            corner_lr=corner_lr,
            spiral_lr=spiral_lr,
            modulo_hv=modulo_hv,
            is_vertical=is_vertical,
            is_spiral=is_spiral,
        )


def tmux_capture(args: Sequence[str]) -> str:
    result = subprocess.run(
        ["tmux", *args],
        stdout=subprocess.PIPE,
        text=True,
        check=True,
    )
    return result.stdout.strip()


def list_panes() -> List[str]:
    return tmux_capture(["list-panes", "-F", "#{pane_id}"]).split()


def re_order_panes_by_history():
    history = tmux_capture(["list-panes", "-F", "#{pane_id} #{pane_active} #{pane_at_top}"])
    panes = []
    active_pane = None
    for line in history.splitlines():
        parts = line.split()
        pane_id = parts[0]
        is_active = parts[1] == "1"
        is_top = parts[2] == "1"
        if is_active:
            active_pane = pane_id
        elif not is_top:
            panes.append(pane_id)
    if active_pane:
        panes.insert(0, active_pane)
    return panes
    


def batch_tmux(commands: Iterable[Sequence[str]]) -> None:
    flattened: List[str] = []
    for command in commands:
        if not command:
            continue
        if flattened:
            flattened.append(";")
        flattened.extend(command)
    if flattened:
        subprocess.run(["tmux", *flattened], check=True)


def should_place_before(
    orientation: Orientation,
    step_index: int,
    split_is_horizontal: bool,
) -> bool:
    # Step sequence for spiral check: if step_index % 5 > 2, use a varying branch
    use_spiral_branch = orientation.is_spiral and step_index % 5 > 2
    if split_is_horizontal:
        return orientation.spiral_lr if use_spiral_branch else orientation.corner_lr
    return orientation.spiral_tb if use_spiral_branch else orientation.corner_tb


def build_commands(
    pane_ids: Sequence[str],
    orientation: Orientation,
    window_extent: int,
    historic_pane: str,
    selected_pane: str,
) -> List[List[str]]:
    layout_name = "even-vertical" if orientation.is_vertical else "even-horizontal"
    resize_flag = "-y" if orientation.is_vertical else "-x"
    commands: List[List[str]] = [["select-layout", layout_name]]
    pane_count = len(pane_ids)

    for index, pane_id in enumerate(pane_ids[:-1], start=1):
        split_is_horizontal = index % 2 == orientation.modulo_hv
        place_before = should_place_before(
            orientation, index, split_is_horizontal=split_is_horizontal
        )

        commands.append(["resize-pane", "-t", pane_id, resize_flag, str(window_extent)])
        commands.append(["select-pane", "-t", pane_id])

        join_cmd: List[str] = ["move-pane", "-d", "-s", ".+1", "-t", "."]
        if split_is_horizontal:
            join_cmd.append("-h")
        if place_before:
            join_cmd.append("-b")
        commands.append(join_cmd)

    branch_extent = window_extent
    for index, pane_id in enumerate(pane_ids, start=1):
        if index == pane_count and not orientation.is_vertical:
            break
        if index % 2 == 1:
            parent_extent = branch_extent
            branch_extent = max(branch_extent // 2, 1)
            resize_val = parent_extent if orientation.is_vertical else branch_extent
            commands.append(
                ["resize-pane", "-t", pane_id, resize_flag, str(resize_val)]
            )

    if historic_pane:
        commands.append(["select-pane", "-t", historic_pane])
    commands.append(["select-pane", "-t", selected_pane])
    return commands


def main(argv: Sequence[str]) -> int:
    orientation = Orientation.from_flags(argv)

    pane_ids = list_panes()
    if len(pane_ids) <= 1:
        return 0

    dim_key = "height" if orientation.is_vertical else "width"
    window_extent_raw = tmux_capture(
        ["display-message", "-p", f"#{{window_{dim_key}}}"]
    )
    window_extent = int(window_extent_raw)

    selected_pane = tmux_capture(["display-message", "-p", "#{pane_id}"])
    historic_pane = get_historic_pane()

    commands = build_commands(
        pane_ids, orientation, window_extent, historic_pane, selected_pane
    )
    batch_tmux(commands)
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
